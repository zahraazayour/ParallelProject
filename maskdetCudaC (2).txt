#include <stdio.h>
#include <stdlib.h>
#include <opencv2/opencv.hpp>
#include <cuda_runtime.h>
#include "maskdetCudaC.h"

using namespace cv;

__global__ void detect_faces_kernel(cv::cuda::PtrStepSz<uchar1> gray, cv::Rect* faces, int* num_faces)
{
    CascadeClassifier face_cascade;
    if (!face_cascade.load("haarcascade_frontalface_default.xml"))
    {
        printf("Error loading cascade classifier\n");
        return;
    }

    std::vector<cv::Rect> faces_vec;
    face_cascade.detectMultiScale(gray, faces_vec, 1.3, 5);

    int num_faces_found = faces_vec.size();
    for (int i = 0; i < num_faces_found; i++)
    {
        faces[i] = faces_vec[i];
    }

    *num_faces = num_faces_found;
}

int main(int argc, char** argv )
{
    // Load pre-trained classifiers for face and face mask detection
    CascadeClassifier mask_cascade;
    if (!mask_cascade.load("haarcascade_mask.xml"))
    {
        printf("Error loading cascade classifier\n");
        return -1;
    }

    // Open default camera
    VideoCapture capture(0);
    if (!capture.isOpened())
    {
        printf("Error opening camera\n");
        return -1;
    }

    // Create a window for displaying the camera feed
    namedWindow("Camera Feed", WINDOW_NORMAL);

    while (true)
    {
        // Read a frame from the camera
        Mat frame;
        capture >> frame;
        if (frame.empty())
        {
            printf("No frame captured from camera\n");
            break;
        }

        // Convert to grayscale
        Mat gray;
        cvtColor(frame, gray, COLOR_BGR2GRAY);

        // Allocate memory for storing the faces
        const int max_faces = 100;
        cv::Rect* faces = new cv::Rect[max_faces];
        int num_faces = 0;

        // Copy the grayscale image to the device memory
        cv::cuda::GpuMat d_gray(gray);

        // Run the face detection kernel
        detect_faces_kernel<<<1, 1>>>(d_gray, faces, &num_faces);

        // Copy the faces back to the host memory
        cv::Rect* faces_host = new cv::Rect[num_faces];
        cudaMemcpy(faces_host, faces, num_faces * sizeof(cv::Rect), cudaMemcpyDeviceToHost);

        // Draw rectangles around the faces and detect masks
        for (int i = 0; i < num_faces; i++)
        {
            // Get the coordinates of the face
            cv::Rect face_rect = faces_host[i];
            Point center(face_rect.x + face_rect.width/2, face_rect.y + face_rect.height/2);

            // Detect masks in the face region
            Mat face_region = gray(face_rect);
            std::vector<Rect> masks;
            mask_cascade.detectMultiScale(face_region, masks, 1.3, 5);

            // Draw a rectangle around the face and label it as masked or unmasked
            Scalar color;
            std::string label;
            if (masks.size() > 0)
            {
                color = Scalar(0, 255, 0); //
label= "masked";
 else
            
            {
                color = Scalar(0, 0, 255); // red
                label = "Unmasked";
            }
            rectangle(frame, face_rect, color, 2);
            putText(frame, label, center, FONT_HERSHEY_SIMPLEX, 1, color, 2);
        }

        // Display the camera feed
        imshow("Camera Feed", frame);

        // Press ESC to quit
        if (waitKey(1) == 27)
            break;
    }

    // Release the camera and destroy the window
    capture.release();
    destroyAllWindows();

    return 0;
}


