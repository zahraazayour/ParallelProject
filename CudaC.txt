#include <opencv2/opencv.hpp>
#include <iostream>
#include <cuda_runtime.h>

using namespace std;
using namespace cv;

// CUDA kernel function for face detection
__global__ void detectFaces(Mat grayFrame, CascadeClassifier faceCascade, vector<Rect> faces) {
    // Get the index of the thread
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    // Detect faces in the frame
    faceCascade.detectMultiScale(grayFrame, faces, 1.1, 3, 0, Size(30, 30));
}

// CUDA kernel function for mask detection
__global__ void detectMasks(Mat grayFace, CascadeClassifier maskCascade, vector<Rect> masks) {
    // Get the index of the thread
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    // Detect masks in the face ROI
    maskCascade.detectMultiScale(grayFace, masks, 1.1, 3, 0, Size(30, 30));
}

int main(int argc, char** argv)
{
    // Load the cascade classifiers for face and mask detection onto the GPU memory
    CascadeClassifier faceCascade;
    faceCascade.load("haarcascade_frontalface_alt.xml");
    CascadeClassifier maskCascade;
    maskCascade.load("haarcascade_mask.xml");
    cudaMalloc(&faceCascade_gpu, sizeof(CascadeClassifier));
    cudaMemcpy(faceCascade_gpu, &faceCascade, sizeof(CascadeClassifier), cudaMemcpyHostToDevice);
    cudaMalloc(&maskCascade_gpu, sizeof(CascadeClassifier));
    cudaMemcpy(maskCascade_gpu, &maskCascade, sizeof(CascadeClassifier), cudaMemcpyHostToDevice);

    // Open the default camera
    VideoCapture cap(0);

    // Check if the camera is opened successfully
    if (!cap.isOpened())
    {
        cout << "Error opening camera" << endl;
        return -1;
    }

    // Create a window to display the camera output
    namedWindow("Face Mask Detection", WINDOW_NORMAL);

    while (true)
    {
        // Read a frame from the camera
        Mat frame;
        cap.read(frame);

        // Convert the frame to grayscale
        Mat grayFrame;
        cvtColor(frame, grayFrame, COLOR_BGR2GRAY);

        // Allocate GPU memory for the grayscale frame
        Mat grayFrame_gpu;
        cudaMalloc(&grayFrame_gpu, grayFrame.rows * grayFrame.cols * sizeof(uchar));
        cudaMemcpy(grayFrame_gpu, grayFrame.data, grayFrame.rows * grayFrame.cols * sizeof(uchar), cudaMemcpyHostToDevice);

        // Detect faces in the frame using CUDA kernel function
        vector<Rect> faces;
        detectFaces<<<1, 1>>>(grayFrame_gpu, faceCascade_gpu, faces);

        // For each face detected, check if a mask is present using CUDA kernel function
        for (size_t i = 0; i < faces.size(); i++)
        {
            // Get the region of interest (ROI) for the face
            Rect faceROI = faces[i];

            // Convert the ROI to grayscale
            Mat grayFace = grayFrame(faceROI);

            // Allocate GPU memory for the grayscale face
            Mat grayFace_gpu;
            cudaMalloc(&grayFace_gpu, grayFace.rows * grayFace.cols * sizeof(uchar));
            cudaMemcpy(grayFace_gpu, grayFace.data, grayFace.rows * grayFace.cols * sizeof(uchar), cudaMemcpyHostToDevice);

            // Detect masks in the face ROI using CUDA kernel function
            vector<Rect> masks;
            detectMasks<<<1, 1>>>(grayFace_gpu, maskCascade_gpu, masks);

            // Copy the results back to the CPU memory using cudaMemcpy
            cudaMemcpy(masks.data(),